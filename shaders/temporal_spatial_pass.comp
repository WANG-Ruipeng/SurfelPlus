#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters

#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_ARB_gpu_shader_int64 : enable       // Debug - heatmap value
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable
#extension GL_KHR_vulkan_glsl : enable

#include "host_device.h"

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

#include "globals.glsl"

layout(set = 0, binding = 0) uniform image2D reflectionColor;
layout(set = 0, binding = 1) uniform image2D reflectionDirection;
layout(set = 0, binding = 2) uniform image2D reflectionPointBrdf;
layout(set = 0, binding = 3) uniform image2D filteredReflectionColor;



//--------------------------------------------------------------------------------------------------
//--------------------------------------------------------------------------------------------------
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{
	ivec2 imageRes = imageSize(reflectionColor); 
    ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);

    if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
        return; 

    vec3 result = vec3(0.0);
    float weightSum = 0.0;

    for (int dy = -1; dy <= 1; dy++) {
        for (int dx = -1; dx <= 1; dx++) {
            ivec2 neighborCoords = imageCoords + ivec2(dx, dy);
            if (neighborCoords.x < 0 || neighborCoords.y < 0 || neighborCoords.x >= imageRes.x || neighborCoords.y >= imageRes.y)
                continue;

            vec4 neighborColor = imageLoad(reflectionColor, neighborCoords);  
            vec4 neighborDirection = imageLoad(reflectionDirection, neighborCoords);
            vec4 neighborBrdf = imageLoad(reflectionPointBrdf, neighborCoords);

            vec3 brdf = neighborBrdf.rgb; 
            float pdf = 1.0 / neighborDirection.a;

            float weight = max(dot(brdf, vec3(1.0)) / pdf, 0.001); 

            result += neighborColor.rgb * weight;
            weightSum += weight;
        }
    }
    if (weightSum > 0.0) {
        result /= weightSum;
    }
    imageStore(filteredReflectionColor, imageCoords, vec4(result, 1.0));
}