#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_debug_printf : enable                 // Debug - printf
#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "host_device.h"
#include "compress.glsl"


// surfel buffers
layout(set = 0, binding = 0,  scalar)		buffer _SurfelCounter		{ SurfelCounter surfelCounter; };
layout(set = 0, binding = 1,  scalar)		buffer _SurfelBuffer		{ Surfel surfelBuffer[]; };
layout(set = 0, binding = 2,  scalar)		buffer _SurfelAlive		    { uint surfelAlive[]; };
layout(set = 0, binding = 3,  scalar)		buffer _SurfelDead		    { uint surfelDead[]; };
layout(set = 0, binding = 4,  scalar)		buffer _SurfelDirty		    { uint surfelDirty[]; };

// gbuffers
layout(set = 1, binding = 0)	uniform usampler2D primObjIDMap;
layout(set = 1, binding = 1)	uniform usampler2D normalMap;
layout(set = 1, binding = 2)	uniform sampler2D depthMap;

// scene buffers
layout(set = 2, binding = 0,  scalar)		uniform _SceneCamera		{ SceneCamera sceneCamera; };

// output buffer
layout(set = 3,   binding = 1)				uniform image2D	resultImage;

// cell buffer
layout(set = 4, binding = 0, scalar)		buffer _CellBuffer			{ CellInfo cellBuffer[]; };
layout(set = 4, binding = 1,  scalar)		buffer _CellCounter			{ CellCounter cellCounter; };
layout(set = 4, binding = 2,  scalar)		buffer _CellToSurfel		{ uint cellToSurfel[]; };

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

#include "shaderUtils.glsl"
#include "random.glsl"

shared uint groupShareMinCoverage;
shared uint groupShareMaxContribution;

// Compute input
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void main()
{

	ivec2 imageRes    = rtxState.size;
	ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(imageCoords) + vec2(0.5f)) / vec2(imageRes);

	if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
	{
		return;
	}
	float depth = texelFetch(depthMap, imageCoords, 0).r;

	if (depth == 1.f)
	{
		return;
	}

	uint randSeed = initRandom(imageRes, imageCoords, rtxState.totalFrames);

	// get the normal
	uint compressedNor = texelFetch(normalMap, imageCoords, 0).r;
	vec3 normal = decompress_unit_vec(compressedNor);
	vec3 worldPos = WorldPosFromDepth(uv, depth);

	vec4 indirectLighting = vec4(0.f);

	uint aliveSurfelCnt = surfelCounter.aliveSurfelCnt;
	float coverage = 0.f;
    float variance = 0.f;
    float maxVariance = 0.f;
    float maxContribution = 0.f;
    uint maxContributionSurfelIndex = 0xffffffff;

	for (uint i = 0; i < aliveSurfelCnt; i++)
	{
		uint surfelIndex = surfelAlive[i];
		Surfel surfel = surfelBuffer[surfelIndex];

		vec3 bias = worldPos - surfel.position;
        float dist2 = dot(bias, bias);

		if (dist2 < surfel.radius * surfel.radius)
        {
            vec3 surfelNor = decompress_unit_vec(surfel.normal);
            float dotN = dot(normal, surfelNor);
            if (dotN > 0.f)
            {
                float dist = sqrt(dist2);
                float contribution = 1.f;

                contribution *= clamp(dotN, 0.f, 1.f);
                contribution *= clamp(1.f - dist / surfel.radius, 0.f, 1.f);
                contribution = smoothstep(0, 1, contribution);

                coverage += contribution;

				indirectLighting += vec4(surfel.radiance, 1.f) * contribution;

				if (maxContribution < contribution)
				{
				    maxContribution = contribution;
				    maxContributionSurfelIndex = surfelIndex;
				}
            }

		
		}
	}

	if (maxContributionSurfelIndex != 0xffffffff)
	{
		Surfel mainSurfel = surfelBuffer[maxContributionSurfelIndex];
		vec3 mainNor = decompress_unit_vec(mainSurfel.normal);
		//imageStore(resultImage, imageCoords, vec4(vec3(mainSurfel.radius), 1.f));
		imageStore(resultImage, imageCoords, vec4(hash3u1(maxContributionSurfelIndex), 1.f));
	}
	else
	{
		imageStore(resultImage, imageCoords, vec4(vec3(0.f), 1.f));
	}
	//imageStore(resultImage, imageCoords, vec4(hash3u1(texelFetch(primObjIDMap, imageCoords, 0).r), 1.f));
	//imageStore(resultImage, imageCoords, vec4(normal * 0.5 + 0.5, 1.f));

	if ((rtxState.frame & 0x000fffff) != 0) return;


	uint coverageData = 0;
    coverageData |= floatBitsToUint(coverage) & 0xFFFF0000;
    coverageData |= ((uint(255 * rand3(randSeed)) & 0x000000FF) << 8);
    coverageData |= ((gl_LocalInvocationID.x & 0x0000000F) << 4);
    coverageData |= ((gl_LocalInvocationID.y & 0x0000000F) << 0);

    atomicMin(groupShareMinCoverage, coverageData);

    uint contributionData = 0;
    contributionData |= floatBitsToUint(maxContribution) & 0xFFFF0000;
    contributionData |= ((maxContributionSurfelIndex & 0x0000FFFF) << 0);

	atomicMax(groupShareMaxContribution, contributionData);

	barrier();

	coverageData = groupShareMinCoverage;
    coverage = uintBitsToFloat(coverageData & 0xFFFF0000);
    uint x = (coverageData & 0x000000F0) >> 4;
    uint y = (coverageData & 0x0000000F) >> 0;

	contributionData = groupShareMaxContribution;
	maxContribution = uintBitsToFloat(contributionData & 0xFFFF0000);
	maxContributionSurfelIndex = contributionData & 0x0000FFFF;

	// replace later
	const uint surfelMaxCount = 10000;

	if (surfelCounter.aliveSurfelCnt < 10000)
	{
		if (gl_LocalInvocationID.x == x && gl_LocalInvocationID.y == y)
		{
			if (coverage < 1.f && rand(randSeed) < depth * 0.2f)
			{
			    uint surfelAliveIndex = atomicAdd(surfelCounter.aliveSurfelCnt,1);
				if (surfelAliveIndex < surfelMaxCount)
				{
					uint surfelID = surfelDead[surfelMaxCount - surfelAliveIndex - 1];
					surfelAlive[surfelAliveIndex] = surfelID;

					// const radius tmp
					Surfel newSurfel;
					newSurfel.position = worldPos;
					newSurfel.normal = compressedNor;
					newSurfel.radiance = vec3(0.f);
					float surfelToCameraDistance = distance(worldPos, getCameraPosition(sceneCamera));
					newSurfel.radius = calcSurfelRadius(surfelToCameraDistance, sceneCamera.fov, vec2(imageRes.x, imageRes.y));
					
					surfelBuffer[surfelID] = newSurfel;
				}
				else
				{
					atomicAdd(surfelCounter.aliveSurfelCnt, -1);
				}
			}
		}
	}

//	Surfel mainSurfel = surfelBuffer[maxContributionSurfelIndex];
//	vec3 mainNor = decompress_unit_vec(mainSurfel.normal);
//	// get the depth value
//	imageStore(resultImage, imageCoords, vec4(vec3(mainNor * 0.5f + 0.5f), 1.f));
	

}