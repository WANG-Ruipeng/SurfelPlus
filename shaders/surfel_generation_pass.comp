#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_debug_printf : enable                 // Debug - printf
#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#include "host_device.h"
#include "compress.glsl"


// surfel buffers
layout(set = 0, binding = 0,  scalar)		buffer _SurfelCounter		{ SurfelCounter surfelCounter; };
layout(set = 0, binding = 1,  scalar)		buffer _SurfelBuffer		{ Surfel surfelBuffer[]; };
layout(set = 0, binding = 2,  scalar)		buffer _SurfelAlive		    { uint surfelAlive[]; };
layout(set = 0, binding = 3,  scalar)		buffer _SurfelDead		    { uint surfelDead[]; };
layout(set = 0, binding = 4,  scalar)		buffer _SurfelDirty		    { uint surfelDirty[]; };
layout(set = 0, binding = 5,  scalar)		buffer _SurfelRecycle		{ SurfelRecycleInfo surfelRecycleInfo[]; };
layout(set = 0, binding = 6,  scalar)		buffer _SurfelRayBuffer		{ SurfelRay surfelRayBuffer[]; };

// gbuffers
layout(set = 1, binding = 0)	uniform usampler2D primObjIDMap;
layout(set = 1, binding = 1)	uniform usampler2D normalMap;
layout(set = 1, binding = 2)	uniform sampler2D depthMap;

// scene buffers
layout(set = 2, binding = 0,  scalar)		uniform _SceneCamera		{ SceneCamera sceneCamera; };

// output buffer
layout(set = 3,   binding = 1)				uniform image2D	resultImage;

// cell buffer
layout(set = 4, binding = 0,  scalar)		buffer _CellBuffer			{ CellInfo cellBuffer[]; };
layout(set = 4, binding = 1,  scalar)		buffer _CellCounter			{ CellCounter cellCounter; };
layout(set = 4, binding = 2,  scalar)		buffer _CellToSurfel		{ uint cellToSurfel[]; };

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

#include "random.glsl"
#include "shaderUtils_surfel_cell.glsl"
#include "shaderUtils.glsl"


shared uint groupShareMinCoverage;
shared uint groupShareMaxContribution;

// Compute input
layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

//bool generateNewSurfel(vec3 worldPos, uint compressedNor, float surfelToCameraDistance, vec2 resolution) {
//
//    // Get surfel index from the top of deadSurfel
//    uint newSurfelIndex = surfelDead[surfelCounter.deadSurfelCnt - 1];
//    
//    // Update Counter
//    uint newAliveIndex = atomicAdd(surfelCounter.aliveSurfelCnt, 1);
//    atomicAdd(surfelCounter.deadSurfelCnt, -1);
//
//    // Calculate life based on current surfel count
//    float surfelRatio = float(surfelCounter.aliveSurfelCnt) / float(kMaxSurfelCount);
//    uint initialLife = kMaxLife;
//    
//    if(surfelRatio > 0.95) {
//        // Linear interpolation between kMaxLife at 0.95 and 0 at 1.0
//        float t = (surfelRatio - 0.95) / 0.05; // normalize to [0,1]
//        initialLife = uint(kMaxLife * (1.0 - t));
//    }
//
//    // new surfel info
//    surfelBuffer[newSurfelIndex].position = worldPos;
//    surfelBuffer[newSurfelIndex].normal = compressedNor;
//    surfelBuffer[newSurfelIndex].radiance = vec3(0.f);
//    surfelBuffer[newSurfelIndex].radius = calcSurfelRadius(surfelToCameraDistance, sceneCamera.fov, resolution);
//
//    // Initialize corresponding recycleInfo with new structure
//    surfelRecycle[newSurfelIndex].life = initialLife;
//    surfelRecycle[newSurfelIndex].frame = 0;
//    surfelRecycle[newSurfelIndex].status = 0;
//    surfelRecycle[newSurfelIndex].lastSeenFrame = 0;
//
//    // add index to surfelAliveBuffer
//    surfelAlive[newAliveIndex] = newSurfelIndex;
//
//    return true;
//}

void main()
{

	ivec2 imageRes    = rtxState.size;
	ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(imageCoords) + vec2(0.5f)) / vec2(imageRes);

	if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
	{
		return;
	}
	float depth = texelFetch(depthMap, imageCoords, 0).r;

	if (depth == 1.f)
	{
		imageStore(resultImage, imageCoords, vec4(0.f, 0.f, 0.f, 1.f));
		return;
	}

	uint objID = texelFetch(primObjIDMap, imageCoords, 0).r;
	uint randSeed = initRandom(imageRes, imageCoords, rtxState.totalFrames);

	// get the normal
	uint compressedNor = texelFetch(normalMap, imageCoords, 0).r;
	vec3 normal = decompress_unit_vec(compressedNor);
	vec3 worldPos = WorldPosFromDepth(uv, depth);

	vec3 indirectLighting = vec3(0.f);

	uint aliveSurfelCnt = surfelCounter.aliveSurfelCnt;
	float coverage = 0.f;
    float variance = 0.f;
    float maxVariance = 0.f;
    float maxContribution = 0.f;
    uint maxContributionSurfelIndex = 0xffffffff;

	vec3 camPos = getCameraPosition(sceneCamera);
	vec3 cellPosIndex = getCellPos(worldPos, camPos);
	uint flattenIndex = getFlattenCellIndex(cellPosIndex);

	CellInfo cellInfo = cellBuffer[flattenIndex];
	uint cellOffset = cellInfo.surfelOffset;
	uint cellSurfelCount = cellInfo.surfelCount; 

	//if(cellOffset != 0 || cellSurfelCount!= 0) debugPrintfEXT("%d, %d\n", cellOffset, cellSurfelCount); 

	for (uint i = 0; i < cellSurfelCount; i++)
	{
		//uint surfelIndex = surfelAlive[i];
		uint surfelIndex = cellToSurfel[cellOffset + i];
		Surfel surfel = surfelBuffer[surfelIndex];
		vec3 bias = worldPos - surfel.position;
        float dist2 = dot(bias, bias);

		if (dist2 < surfel.radius * surfel.radius)
        {
            vec3 surfelNor = decompress_unit_vec(surfel.normal);
            float dotN = dot(normal, surfelNor);
            if (dotN > 0.f)
            {
                float dist = sqrt(dist2);
                float contribution = 1.f;

                contribution *= clamp(dotN, 0.f, 1.f);
                contribution *= clamp(1.f - dist / surfel.radius, 0.f, 1.f);
                contribution = smoothstep(0, 1, contribution);


                coverage += contribution;

				indirectLighting += surfel.radiance * contribution * smoothstep(0.f, 200.f, float(surfelRecycleInfo[surfelIndex].frame));

				if (maxContribution < contribution)
				{
				    maxContribution = contribution;
				    maxContributionSurfelIndex = surfelIndex;
				}
            }

			// update recycle lastseen
			surfelRecycleInfo[surfelIndex].status |= 0x0002u;
		
		}
	}

	if (maxContributionSurfelIndex != 0xffffffff)
	{
		Surfel mainSurfel = surfelBuffer[maxContributionSurfelIndex];
		vec3 mainNor = decompress_unit_vec(mainSurfel.normal);
		//imageStore(resultImage, imageCoords, vec4(vec3(mainSurfel.radius), 1.f));
		//imageStore(resultImage, imageCoords, vec4(hash3u1(maxContributionSurfelIndex), 1.f));
		//imageStore(resultImage, imageCoords, vec4(mainSurfel.msmeData.variance, 1.f));
	}
	else
	{
		//imageStore(resultImage, imageCoords, vec4(vec3(0.f), 1.f));
	}
	//imageStore(resultImage, imageCoords, vec4(hash3u1(texelFetch(primObjIDMap, imageCoords, 0).r), 1.f));
	//imageStore(resultImage, imageCoords, vec4(normal * 0.5 + 0.5, 1.f));
	if(rtxState.debugging_mode != eNoDebug)
	{
		Surfel mainSurfel = surfelBuffer[maxContributionSurfelIndex];
		if(rtxState.debugging_mode == esRadiance)
			imageStore(resultImage, imageCoords, vec4(indirectLighting, 1.f));
		else if(rtxState.debugging_mode == esSurfelID && maxContributionSurfelIndex != 0xffffffff) 
			imageStore(resultImage, imageCoords, vec4(hash3u1(maxContributionSurfelIndex), 1.f));
		else if (rtxState.debugging_mode == esVariance && maxContributionSurfelIndex != 0xffffffff)
			imageStore(resultImage, imageCoords, vec4(mainSurfel.msmeData.variance, 1.f));
		else if (rtxState.debugging_mode == esRadius && maxContributionSurfelIndex != 0xffffffff)
			imageStore(resultImage, imageCoords, vec4(vec3(mainSurfel.radius), 1.f));
		else imageStore(resultImage, imageCoords, vec4(vec3(0), 1.f));
	} else imageStore(resultImage, imageCoords, vec4(indirectLighting, 1.f));

	//if ((rtxState.totalFrames & 0x000000ff) != 0) return;

	coverage += rand(randSeed) * 1e-10;
	uint coverageData = floatBitsToUint(coverage);
	atomicMin(groupShareMinCoverage, coverageData);

	maxContribution += rand(randSeed) * 1e-10;
	uint contributionData = floatBitsToUint(maxContribution);
	atomicMax(groupShareMaxContribution, contributionData);

	barrier();

	float groupMinCoverage = uintBitsToFloat(groupShareMinCoverage);
	float groupMaxContribution = uintBitsToFloat(groupShareMaxContribution);

	
//	if ( surfelCounter.aliveSurfelCnt < kMaxSurfelCount &&
//		coverage == groupMinCoverage &&
//		coverage < 2.f && 
//		rand(randSeed) < depth * 0.2f)
//		{
//			float surfelToCameraDistance = distance(worldPos, getCameraPosition(sceneCamera));
//			generateNewSurfel(worldPos, compressedNor, surfelToCameraDistance, vec2(imageRes.x, imageRes.y));
//		}
//
//	imageStore(resultImage, imageCoords, vec4(indirectLighting, 1.f));

//	uint coverageData = 0;
//    coverageData |= floatBitsToUint(coverage) & 0xFFFF0000;
//    coverageData |= ((uint(255 * rand3(randSeed)) & 0x000000FF) << 8);
//    coverageData |= ((gl_LocalInvocationID.x & 0x0000000F) << 4);
//    coverageData |= ((gl_LocalInvocationID.y & 0x0000000F) << 0);
//
//    atomicMin(groupShareMinCoverage, coverageData);
//
//    uint contributionData = 0;
//    contributionData |= floatBitsToUint(maxContribution) & 0xFFFF0000;
//    contributionData |= ((maxContributionSurfelIndex & 0x0000FFFF) << 0);
//
//	atomicMax(groupShareMaxContribution, contributionData);
//
//	barrier();
//
//	coverageData = groupShareMinCoverage;
//    coverage = uintBitsToFloat(coverageData & 0xFFFF0000);
//    uint x = (coverageData & 0x000000F0) >> 4;
//    uint y = (coverageData & 0x0000000F) >> 0;
//
//	contributionData = groupShareMaxContribution;
//	maxContribution = uintBitsToFloat(contributionData & 0xFFFF0000);
//	maxContributionSurfelIndex = contributionData & 0x0000FFFF;


	if (surfelCounter.aliveSurfelCnt < kMaxSurfelCount &&
		coverage == groupMinCoverage &&
		coverage < 2.f && 
		rand(randSeed) < depth * 0.3f)
	{
		uint surfelAliveIndex = atomicAdd(surfelCounter.aliveSurfelCnt,1);
		if (surfelAliveIndex < kMaxSurfelCount)
		{
			uint surfelID = surfelDead[kMaxSurfelCount - surfelAliveIndex - 1];
			surfelAlive[surfelAliveIndex] = surfelID;

			Surfel newSurfel;
			newSurfel.objID = objID;
			newSurfel.position = worldPos;
			newSurfel.normal = compressedNor;
			newSurfel.radiance = indirectLighting;
			newSurfel.msmeData.mean = indirectLighting.xyz;
            newSurfel.msmeData.shortMean = indirectLighting.xyz;
			newSurfel.msmeData.vbbr = 0.f;
			newSurfel.msmeData.variance = vec3(1.f);
			newSurfel.msmeData.inconsistency = 1.f;
			float surfelToCameraDistance = distance(worldPos, getCameraPosition(sceneCamera));
			newSurfel.radius = min(calcSurfelRadius(surfelToCameraDistance, sceneCamera.fov, vec2(imageRes.x, imageRes.y)), cellSize * 0.5f);



			surfelBuffer[surfelID] = newSurfel;

			SurfelRecycleInfo newSurfelRecycleInfo;
			newSurfelRecycleInfo.life = kMaxLife;
			newSurfelRecycleInfo.frame = 0;
			newSurfelRecycleInfo.status = 0;
			surfelRecycleInfo[surfelID] = newSurfelRecycleInfo;
		}
		else
		{
			atomicAdd(surfelCounter.aliveSurfelCnt, -1);
		}
	}

	if (surfelCounter.aliveSurfelCnt > 0 && maxContribution == groupMaxContribution)
    {
        if (coverage > 4.0)
        {
            if (rand(randSeed) < depth * 0.3f)
            {
                surfelBuffer[maxContributionSurfelIndex].radius = 0.f;
            }
        }
    }

//Surfel mainSurfel = surfelBuffer[maxContributionSurfelIndex];
//imageStore(resultImage, imageCoords, vec4(mainSurfel.radiance, 1.f));
//	vec3 mainNor = decompress_unit_vec(mainSurfel.normal);
//	// get the depth value
//	imageStore(resultImage, imageCoords, vec4(vec3(mainNor * 0.5f + 0.5f), 1.f));
//imageStore(resultImage, imageCoords, vec4(vec3(coverage), 1.f));
	//imageStore(resultImage, imageCoords, vec4(vec3(cellSurfelCount) / 500.f, 1.f));
	
}