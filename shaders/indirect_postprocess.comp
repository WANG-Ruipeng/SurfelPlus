#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_debug_printf : enable                 // Debug - printf
#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require


#include "host_device.h"

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};


#include "globals.glsl"
#include "random.glsl"

// scene buffers
layout(set = 0, binding = 0,  scalar)		uniform _SceneCamera		{ SceneCamera sceneCamera; };

// gbuffers
layout(set = 1, binding = 0)	uniform usampler2D primObjIDMap;
layout(set = 1, binding = 1)	uniform usampler2D normalMap;
layout(set = 1, binding = 2)	uniform sampler2D depthMap;

// indirect buffer
layout(set = 2,   binding = 1)				uniform image2D	resultImage;


// Compute input
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main()
{
	ivec2 imageRes    = rtxState.size / 2;
	ivec2 imageCoords = ivec2(gl_GlobalInvocationID.xy);
	vec2 uv = (vec2(imageCoords) + vec2(0.5f)) / vec2(imageRes);

	if (imageCoords.x >= imageRes.x || imageCoords.y >= imageRes.y)
	{
		return;
	}
	float depth = texelFetch(depthMap, imageCoords * 2, 0).r;

	if (depth == 1.f)
	{
		return;
	}
}