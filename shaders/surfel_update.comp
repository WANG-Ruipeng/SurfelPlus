#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_debug_printf : enable                 // Debug - printf
#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "host_device.h"
#include "compress.glsl"
#include "random.glsl"

// surfel buffers
layout(set = 0, binding = 0,  scalar)		buffer _SurfelCounter		{ SurfelCounter surfelCounter; };
layout(set = 0, binding = 1,  scalar)		buffer _SurfelBuffer		{ Surfel surfelBuffer[]; };
layout(set = 0, binding = 2,  scalar)		buffer _SurfelAlive		    { uint surfelAlive[]; };
layout(set = 0, binding = 3,  scalar)		buffer _SurfelDead		    { uint surfelDead[]; };
layout(set = 0, binding = 4,  scalar)		buffer _SurfelDirty		    { uint surfelDirty[]; };
layout(set = 0, binding = 5,  scalar)		buffer _SurfelRecycle		{ SurfelRecycleInfo surfelRecycleInfo[]; };
layout(set = 0, binding = 6,  scalar)		buffer _SurfelRayBuffer		{ SurfelRay surfelRayBuffer[]; };

// cell buffer
layout(set = 1, binding = 0,  scalar)		buffer _CellBuffer			{ CellInfo cellBuffer[]; };
layout(set = 1, binding = 1,  scalar)		buffer _CellCounter			{ CellCounter cellCounter; };
layout(set = 1, binding = 2,  scalar)		buffer _CellToSurfel		{ uint cellToSurfel[]; };

// scene buffers
layout(set = 2, binding = 0,  scalar)		uniform _SceneCamera		{ SceneCamera sceneCamera; };

// gbuffers
layout(set = 3, binding = 0)	uniform usampler2D primObjIDMap;
layout(set = 3, binding = 1)	uniform usampler2D normalMap;
layout(set = 3, binding = 2)	uniform sampler2D depthMap;

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

#include "shaderUtils.glsl"

void recycleSurfelInAlive(uint aliveArrayIndex) {
    // Get the actual surfelID
    uint surfelIndexToRecycle = surfelAlive[aliveArrayIndex]; 

    // Update alive counter atomically
    uint newAliveCnt = atomicAdd(surfelCounter.aliveSurfelCnt, -1) - 1;
	uint endSurfelIndex = surfelAlive[newAliveCnt];

	// insert end surfel to new position
	surfelAlive[aliveArrayIndex] = endSurfelIndex;

	// recycle to dead buffer
    uint newDeadIndex = kMaxSurfelCount - newAliveCnt - 1;
	surfelDead[newDeadIndex] = surfelIndexToRecycle;



//    // Add to dead stack
//    surfelDead[newDeadIndex] = surfelIndexToRecycle;
//
//    // Move last active surfel to the current position atomically
//    if (aliveArrayIndex < oldAliveCnt - 1) {
//        atomicExchange(surfelAlive[aliveArrayIndex], surfelAlive[oldAliveCnt - 1]);
//    }
}


bool shouldRecycleSurfel(Surfel surfel, SurfelRecycleInfo recycleInfo, float surfelToCameraDistance) {

    // base check
    if(surfel.radius <= 0.01 || recycleInfo.life == 0) {
        return true;
    }
	else
	{
	    return false;
	}


    // Distance factor - recycle if too far
    float distanceFactor = smoothstep(50.0, 100.0, surfelToCameraDistance);
    
    // Normal factor - recycle if facing away from camera
    vec3 viewDir = normalize(getCameraPosition(sceneCamera) - surfel.position);
    vec3 surfelNormal = decompress_unit_vec(surfel.normal);
    float normalFactor = 1.0 - max(0.0, dot(viewDir, surfelNormal));
    
    // Life cycle factor
    float lifeFactor = (float(recycleInfo.frame) - float(recycleInfo.lastSeenFrame)) / float(recycleInfo.life);

    // Combine factors with weights
    float recycleProb = 0.01 * distanceFactor +
                       0.02 * normalFactor +
                        0.5 * lifeFactor;
    
    // Scale by surfel density
    float surfelCountFactor = float(surfelCounter.aliveSurfelCnt) / float(kMaxSurfelCount);
    recycleProb *= surfelCountFactor;

    // Generate random number for discard
    // Use multiple components to improve randomness
    uint randSeed = tea(
        floatBitsToUint(surfel.position.x) ^ 
        floatBitsToUint(surfel.position.y) ^ 
        floatBitsToUint(surfel.position.z), 
        rtxState.frame
    );
    
    // Use rand() instead of direct tea result for better distribution
    return rand(randSeed) < recycleProb;
}

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	// Calculate how much surfels are located at cell.
	// Do not use dirty any more.
	// Still put it in descriptors for future use.

	if(idx >= surfelCounter.aliveSurfelCnt) return;

	uint surfelIndex = surfelAlive[idx];
    Surfel surfel = surfelBuffer[surfelIndex];

	float surfelRadius = surfel.radius;
	SurfelRecycleInfo recycleInfo = surfelRecycleInfo[surfelIndex];
	uint isSleeping = recycleInfo.status & 0x0001u;
	uint lastSeen = recycleInfo.status & 0x0002u;

	// Increase frame count
	recycleInfo.life = max(recycleInfo.life - 1, 0);
	recycleInfo.frame = uint(clamp(int(recycleInfo.frame) + 1, 0, 65535));

	// Check surfel is seen at last frame.
	// If so, reset life, and if surfel is sleeping, awake.
	if(lastSeen != 0u){
		//recycleInfo.lastSeenFrame = recycleInfo.frame;
		recycleInfo.life = 100;
		if(isSleeping != 0u){ isSleeping = 0u; }
	}

	// reset lastSeen
	recycleInfo.status = recycleInfo.status & (~0x0002);
	// write back
	surfelRecycleInfo[surfelIndex] = recycleInfo;

	// TODO: Check surfel is sleeping and have enough light pointing towards it,
	float surfelToCameraDistance = distance(surfel.position, getCameraPosition(sceneCamera));
	// Check if surfel valid
	if(!shouldRecycleSurfel(surfel, recycleInfo, surfelToCameraDistance)){
		// Get surfel position & normal and reset it to current frame's position
		// Since we are only doing static mesh, this is not necessary
		// And it also saves the space of mapping surfel to triangle

		// Reset surfel radius
		float surfelToCameraDistance = distance(surfel.position, getCameraPosition(sceneCamera));
		float fov = sceneCamera.fov;
		ivec2 imageRes = rtxState.size;
		vec2 resolution = vec2(imageRes.x, imageRes.y);
		float newRadius =  calcSurfelRadius(surfelToCameraDistance, fov, resolution);
		if(isSleeping != 0u) {
			surfel.radius = max(newRadius, cellSize * 0.5f);
		}else{
			surfel.radius = newRadius;
		}
		
		// Calculate number of surfels located at cell
		vec3 camPos = getCameraPosition(sceneCamera);
		vec3 cellPosIndex = getCellPos(surfel.position,camPos,cellSize);
		for(uint i = 0; i < 27; i++)
		{
			//iterate through 3x3x3 cell neighbours, put surfel into all neighbours cells
			vec3 neighbourPos = cellPosIndex + neighborOffset[i];
			if (isSurfelIntersectCell(surfel, neighbourPos, camPos, cellSize))
			{
				uint flattenIndex = getFlattenCellIndex(neighbourPos);
				atomicAdd(cellBuffer[flattenIndex].surfelCount, 1);
			}
		}

		//Update ray information
		// use constant ray count (tmp)
		uint rayRequestCnt = uint(mix(4.0, 64.0, clamp(length(surfel.msmeData.variance) * 1.2f, 0.f, 1.f)));
		if (recycleInfo.frame < 2) rayRequestCnt = 64;

		// allocate ray buffer
		uint rayOffset = atomicAdd(surfelCounter.surfelRayCnt, rayRequestCnt);
		if (rayOffset < 320000)
        {
            surfel.rayOffset = rayOffset;
            surfel.rayCount = rayRequestCnt;

            SurfelRay initSurfelRay;
            initSurfelRay.surfelID = surfelIndex;

            for (uint rayIndex = 0; rayIndex < rayRequestCnt; ++rayIndex)
			{
				surfelRayBuffer[rayOffset + rayIndex] = initSurfelRay;
			}   
        }
		else
		{
			atomicAdd(surfelCounter.surfelRayCnt, -rayRequestCnt);
		}

		// Update surfel
		surfelBuffer[surfelIndex] = surfel;
	}
	else
	{
		recycleSurfelInAlive(idx);
	}
	
	return;
}