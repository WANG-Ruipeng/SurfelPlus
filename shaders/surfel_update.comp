#version 460

#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_ray_query : enable
#extension GL_ARB_shader_clock : enable                 // Using clockARB
#extension GL_EXT_shader_image_load_formatted : enable  // The folowing extension allow to pass images as function parameters
#extension GL_EXT_debug_printf : enable                 // Debug - printf
#extension GL_NV_shader_sm_builtins : require     // Debug - gl_WarpIDNV, gl_SMIDNV
#extension GL_EXT_shader_realtime_clock : enable  // Debug - heatmap timing

#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "host_device.h"
#include "compress.glsl"

// surfel buffers
layout(set = 0, binding = 0,  scalar)		buffer _SurfelCounter		{ SurfelCounter surfelCounter; };
layout(set = 0, binding = 1,  scalar)		buffer _SurfelBuffer		{ Surfel surfelBuffer[]; };
layout(set = 0, binding = 2,  scalar)		buffer _SurfelAlive		    { uint surfelAlive[]; };
layout(set = 0, binding = 3,  scalar)		buffer _SurfelDead		    { uint surfelDead[]; };
layout(set = 0, binding = 4,  scalar)		buffer _SurfelDirty		    { uint surfelDirty[]; };
layout(set = 0, binding = 5,  scalar)		buffer _SurfelRecycle		{ SurfelRecycleInfo surfelRecycleInfo[]; };

// cell buffer
layout(set = 1, binding = 0,  scalar)		buffer _CellBuffer			{ CellInfo cellBuffer[]; };
layout(set = 1, binding = 1,  scalar)		buffer _CellCounter			{ CellCounter cellCounter; };
layout(set = 1, binding = 2,  scalar)		buffer _CellToSurfel		{ uint cellToSurfel[]; };

// scene buffers
layout(set = 2, binding = 0,  scalar)		uniform _SceneCamera		{ SceneCamera sceneCamera; };

// gbuffers
layout(set = 3, binding = 0)	uniform usampler2D primObjIDMap;
layout(set = 3, binding = 1)	uniform usampler2D normalMap;
layout(set = 3, binding = 2)	uniform sampler2D depthMap;

layout(push_constant) uniform _RtxState
{
  RtxState rtxState;
};

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

#include "shaderUtils.glsl"

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	{
		// Calculate how much surfels are located at cell.
		if(idx > surfelCounter.dirtySurfelCnt) return;

		uint surfelIndex = surfelDirty[idx];
		Surfel surfel = surfelBuffer[surfelIndex];

		float surfelRadius = surfel.radius;
		SurfelRecycleInfo surfelRecycleInfo = surfelRecycleInfo[surfelIndex];
		uint isSleeping = surfelRecycleInfo.status & 0x0001u;
		uint lastSeen = surfelRecycleInfo.status & 0x0002u;

		// Increase frame count and reduce life.
		surfelRecycleInfo.life = uint(max(int(surfelRecycleInfo.life) - 1, 0));
		surfelRecycleInfo.frame = uint(clamp(int(surfelRecycleInfo.frame) + 1, 0, 65535));

		// Check surfel is seen at last frame.
		// If so, reset life, and if surfel is sleeping, awake.
		if(lastSeen != 0u){
			surfelRecycleInfo.life = maxSurfelLife;
			if(isSleeping != 0u){ isSleeping = 0u; }
		}

		// TODO: Check surfel is sleeping and have enough light pointing towards it,
		// If yes, set to sleepMaxLife
		/*if(isSleeping != 0u){
			surfelRecycleInfo.life = kSleepingMaxLife;
		}*/

		// Check if surfel valid
		if(surfelRadius > 0 && surfelRecycleInfo.life > 0){
			uint validSurfelCount = atomicAdd(surfelCounter.aliveSurfelCnt, 1);
			surfelAlive[validSurfelCount] = surfelIndex;

			// Get surfel position & normal and reset it to current frame's position
			// Since we are only doing static mesh, this is not necessary
			// And it also saves the space of mapping surfel to triangle

			// Reset surfel radius
			float surfelToCameraDistance = distance(surfel.position, getCameraPosition(sceneCamera));
			float fov = sceneCamera.fov;
			ivec2 imageRes = rtxState.size;
			vec2 resolution = vec2(imageRes.x, imageRes.y);
			float newRadius =  calcSurfelRadius(surfelToCameraDistance, fov, resolution);
			if(isSleeping != 0u) {
				surfel.radius = max(newRadius, cellSize * 0.5f);
			}else{
				surfel.radius = newRadius;
			}
				
			// Calculate number of surfels located at cell
			vec3 camPos = getCameraPosition(sceneCamera);
			vec3 cellPosIndex = getCellPos(surfel.position,camPos,cellSize);
			for(uint i = 0; i < 125; i++){
			//iterate through 3x3x3 cell neighbours, put surfel into all neighbours cells
			vec3 neighbourPos = cellPosIndex + neighborOffset[i];
			if (isSurfelIntersectCell(surfel, neighbourPos, camPos, cellSize)){
				uint flattenIndex = getFlattenCellIndex(neighbourPos);
				atomicAdd(cellBuffer[flattenIndex].surfelCount, 1);
			}

			//TODO: Update ray information

		}
		}else{
			uint deadSurfelCount = atomicAdd(surfelCounter.deadSurfelCnt, 1);
			surfelDead[deadSurfelCount] = deadSurfelCount;
		}
	}
	return;
	{
		 // Compute offset of the cell to surfel buffer
		if(idx > cellCounter.totalCellCount) return;

		// Get the cell to process
		CellInfo thisCell = cellBuffer[idx];
		if(thisCell.surfelCount == 0) return;

		// Calculate offsets of the surfel buffer
		uint offset = atomicAdd(surfelCounter.aliveSurfelCnt, thisCell.surfelCount);
		cellBuffer[idx].surfelOffset = offset;
		thisCell.surfelCount = 0;
	}

	{
		// Update _CellToSurfel buffer
		if(idx > surfelCounter.aliveSurfelCnt) return;

		//Get the surfel cell position to process
		uint surfelIndex = surfelAlive[idx];
		Surfel surfel = surfelBuffer[surfelIndex];
		vec3 camPos = getCameraPosition(sceneCamera);
		vec3 cellPosIndex = getCellPos(surfel.position,camPos,cellSize);

		for(uint i = 0; i < 125; i++){
		//iterate through 3x3x3 cell neighbours, put surfel into all neighbours cells
			vec3 neighbourPos = cellPosIndex + neighborOffset[i];
			if (isSurfelIntersectCell(surfel, neighbourPos, camPos, cellSize)){
				uint flattenIndex = getFlattenCellIndex(neighbourPos);
				uint prevCount = atomicAdd(cellBuffer[flattenIndex].surfelCount, 1);
				cellToSurfel[cellBuffer[flattenIndex].surfelOffset + prevCount] = surfelIndex;
			}
		}


	}

}